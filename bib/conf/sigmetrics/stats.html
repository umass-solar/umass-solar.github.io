<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI-generated SIGMETRICS Authors Dashboard (dblp)</title>
  <meta name="color-scheme" content="light dark" />

  <style>
    :root{
      --bg: #0b0f14;
      --panel: #121925;
      --panel2:#0f1520;
      --text:#e8eef6;
      --muted:#a9b4c3;
      --accent:#6ee7ff;
      --accent2:#a78bfa;
      --border: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* System preference default */
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f7fafc;
        --panel:#ffffff;
        --panel2:#f3f6fb;
        --text:#101828;
        --muted:#475467;
        --border: rgba(16,24,40,.10);
        --shadow: 0 10px 30px rgba(16,24,40,.10);
      }
    }

    /* Manual override via <html data-theme="..."> */
    html[data-theme="dark"]{
      color-scheme: dark;
      --bg: #0b0f14;
      --panel: #121925;
      --panel2:#0f1520;
      --text:#e8eef6;
      --muted:#a9b4c3;
      --border: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    html[data-theme="light"]{
      color-scheme: light;
      --bg:#f7fafc;
      --panel:#ffffff;
      --panel2:#f3f6fb;
      --text:#101828;
      --muted:#475467;
      --border: rgba(16,24,40,.10);
      --shadow: 0 10px 30px rgba(16,24,40,.10);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 10% 0%, rgba(110,231,255,.15), transparent 60%),
                  radial-gradient(900px 600px at 90% 10%, rgba(167,139,250,.18), transparent 55%),
                  var(--bg);
      color: var(--text);
    }
    .topbar{
      position: sticky; top:0; z-index: 10;
      backdrop-filter: blur(10px);
      background: color-mix(in oklab, var(--bg) 80%, transparent);
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner{
      max-width: 1300px;
      margin: 0 auto;
      padding: 14px 18px;
      display:flex; gap:14px; align-items:center; justify-content:space-between;
    }
    .brand{display:flex; align-items:center; gap:10px;}
    .dot{
      width: 12px; height: 12px; border-radius: 999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 6px color-mix(in oklab, var(--accent) 18%, transparent);
    }
    .titleblock h1{margin:0; font-size: 16px; letter-spacing: .2px; line-height: 1.2;}
    .titleblock .sub{margin:2px 0 0; font-size: 12px; color: var(--muted);}
    .actions{display:flex; gap:10px; align-items:center; flex-wrap: wrap; justify-content:flex-end;}
    .pill{
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 12px;
      background: color-mix(in oklab, var(--panel) 92%, transparent);
      box-shadow: var(--shadow);
      display:flex; gap:8px; align-items:center;
      font-size: 12px; color: var(--muted);
    }
    .pill b{color:var(--text); font-weight:600}
    .btn{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, color-mix(in oklab, var(--panel) 92%, transparent), color-mix(in oklab, var(--panel) 86%, transparent));
      color: var(--text);
      padding: 10px 12px;
      font-size: 12px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: transform .05s ease;
      user-select:none;
      display:flex; gap:8px; align-items:center;
    }
    .btn:hover{transform: translateY(-1px)}
    .btn:active{transform: translateY(0px)}
    .btn.secondary{background: color-mix(in oklab, var(--panel2) 95%, transparent); box-shadow: none;}
    .container{max-width: 1300px; margin: 0 auto; padding: 18px;}
    .grid{display:grid; grid-template-columns: 360px 1fr; gap: 14px; align-items:start;}
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr} }
    .card{
      background: color-mix(in oklab, var(--panel) 92%, transparent);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card .hd h2{margin:0; font-size: 13px; letter-spacing: .2px;}
    .card .bd{padding: 14px}
    .kpis{display:grid; grid-template-columns: 1fr 1fr; gap: 10px;}
    .kpi{
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel2) 94%, transparent);
    }
    .kpi .label{font-size: 11px; color: var(--muted)}
    .kpi .value{font-size: 18px; font-weight: 700; margin-top: 4px}
    .kpi .hint{font-size: 11px; color: var(--muted); margin-top: 2px}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .field{display:flex; flex-direction:column; gap:6px; width: 100%; margin-bottom: 12px;}
    label{font-size: 11px; color: var(--muted); display:flex; justify-content:space-between; gap:10px;}
    input[type="text"], select{
      width: 100%;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel2) 95%, transparent);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      outline:none;
      font-size: 13px;
    }
    input[type="range"]{width:100%}
    .small{font-size: 11px; color: var(--muted)}
    .progress{width: 100%; height: 10px; border-radius: 999px; border: 1px solid var(--border); background: color-mix(in oklab, var(--panel2) 92%, transparent); overflow:hidden;}
    .bar{height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width .2s ease;}
    .status{font-family: var(--mono); font-size: 11px; color: var(--muted); white-space: pre-wrap; line-height: 1.35;}
    .charts{display:grid; grid-template-columns: 1fr 1fr; gap: 14px;}
    @media (max-width: 1100px){ .charts{grid-template-columns: 1fr} }
    .chart{height: 330px;}
    .tablewrap{overflow:auto; max-height: 520px; border-radius: 14px; border: 1px solid var(--border);}
    table{width: 100%; border-collapse: collapse; min-width: 900px; font-size: 12px;}
    th, td{padding: 10px 10px; border-bottom: 1px solid var(--border); text-align: left; vertical-align: top;}
    th{
      position: sticky; top:0;
      background: color-mix(in oklab, var(--panel) 92%, transparent);
      cursor: pointer;
      user-select:none;
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .25px;
      text-transform: uppercase;
    }
    tr:hover td{background: color-mix(in oklab, var(--panel2) 92%, transparent);}
    .badge{
      display:inline-flex; gap:6px; align-items:center;
      padding: 4px 8px; border-radius: 999px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel2) 94%, transparent);
      color: var(--muted); font-size: 11px; white-space: nowrap;
    }
    .badge .b{width: 7px; height: 7px; border-radius:999px; background: var(--accent);}
    .muted{color: var(--muted)}
    .link{
      color: color-mix(in oklab, var(--accent) 90%, var(--text));
      text-decoration: underline;
      text-underline-offset: 3px;
      cursor:pointer;
    }
    .rightTitle{display:flex; flex-direction:column; gap:3px;}
    .rightTitle .big{
      font-size: 16px; font-weight: 750; letter-spacing: .2px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:baseline;
    }
    .rightTitle .meta{font-size: 12px; color: var(--muted); display:flex; gap:10px; flex-wrap:wrap;}
    .toast{
      position: fixed; bottom: 16px; left: 16px;
      max-width: 520px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--panel) 92%, transparent);
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 12px;
      display:none;
    }
    .toast.show{display:block}
    .mono{font-family: var(--mono)}

    /* Small nicer select in the topbar pill */
    .pill select{
      border: 0;
      background: transparent;
      color: inherit;
      outline: none;
      font-size: 12px;
      padding: 0;
      width: auto;
    }
  </style>

  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="dot"></div>
        <div class="titleblock">
          <h1>AI-generated SIGMETRICS Authors Dashboard</h1>
          <div class="sub">Offline-first (local JSON) with dblp JSONP fallback Â· Author identity merged by pid</div>
        </div>
      </div>
      <div class="actions">
        <div class="pill" title="Choose light/dark theme">
          <span>Theme:</span>
          <select id="themeSelect" aria-label="Theme selector">
            <option value="system">System</option>
            <option value="dark">Dark</option>
            <option value="light">Light</option>
          </select>
        </div>

        <div class="pill">
          <span>Records:</span> <b id="recCount">â€”</b>
          <span>Â· Authors:</span> <b id="authCount">â€”</b>
          <span>Â· Years:</span> <b id="yearSpan">â€”</b>
        </div>
        <button class="btn secondary" id="btnClearCache">ðŸ§¹ Clear cache</button>
        <button class="btn" id="btnLoad">âš¡ Load / Refresh from dblp</button>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="grid">
      <div class="card">
        <div class="hd">
          <h2>Controls</h2>
          <span class="badge"><span class="b"></span><span id="cacheState">cache: unknown</span></span>
        </div>
        <div class="bd">
          <div class="field">
            <label>Search author <span class="small" id="matchCount">â€”</span></label>
            <input id="qAuthor" type="text" placeholder="Matches canonical name or any alias variantâ€¦" />
          </div>

          <div class="row">
            <div class="field" style="flex:1; min-width:160px">
              <label>Sort by</label>
              <select id="sortMetric">
                <option value="pubs">Publications</option>
                <option value="firstAuth">First-author pubs</option>
                <option value="lastAuth">Last-author pubs</option>
                <option value="activeYears">Active years</option>
                <option value="coauthors">Unique coauthors</option>
                <option value="solo">Solo pubs</option>
                <option value="avgTeam">Avg team size</option>
              </select>
            </div>
            <div class="field" style="flex:1; min-width:160px">
              <label>Min publications</label>
              <select id="minPubs">
                <option value="1">1+</option>
                <option value="2">2+</option>
                <option value="3">3+</option>
                <option value="5">5+</option>
                <option value="10">10+</option>
                <option value="20">20+</option>
              </select>
            </div>
          </div>

          <div class="field">
            <label>Year range <span class="small mono" id="yearRangeLabel">â€”</span></label>
            <div class="row">
              <!-- âœ… Default year range requested: 2015â€“2026 -->
              <input id="yearMin" type="range" min="1974" max="2026" value="2010" />
              <input id="yearMax" type="range" min="1974" max="2026" value="2026" />
            </div>
            <div class="small muted">
              Offline-first: place <span class="mono">./data/sigmetrics.json</span> next to this HTML and serve via HTTP
              (e.g. <span class="mono">python3 -m http.server</span>).
              If missing, the page falls back to dblp JSONP.
            </div>
          </div>

          <div class="field">
            <label>Load status</label>
            <div class="progress"><div class="bar" id="progBar"></div></div>
            <div class="status" id="statusLog">Idle.</div>
          </div>

          <div class="kpis">
            <div class="kpi">
              <div class="label">Top author (by pubs)</div>
              <div class="value" id="kTopAuthor">â€”</div>
              <div class="hint" id="kTopAuthorHint">â€”</div>
            </div>
            <div class="kpi">
              <div class="label">Median team size</div>
              <div class="value" id="kMedTeam">â€”</div>
              <div class="hint" id="kMedTeamHint">â€”</div>
            </div>
            <div class="kpi">
              <div class="label">Median pubs / author</div>
              <div class="value" id="kMedPubs">â€”</div>
              <div class="hint" id="kMedPubsHint">â€”</div>
            </div>
            <div class="kpi">
              <div class="label">Most active year</div>
              <div class="value" id="kTopYear">â€”</div>
              <div class="hint" id="kTopYearHint">â€”</div>
            </div>
          </div>

        </div>
      </div>

      <div class="card">
        <div class="hd">
          <div class="rightTitle">
            <div class="big">
              <span id="selAuthor">Select an author</span>
              <span class="badge" id="selBadge" style="display:none"><span class="b"></span><span id="selBadgeText"></span></span>
            </div>
            <div class="meta" id="selMeta">Click a row in the table to inspect an author.</div>
          </div>
          <div class="row">
            <span class="badge"><span class="b"></span><span id="datasetStamp">dataset: â€”</span></span>
          </div>
        </div>

        <div class="bd">
          <div class="charts">
            <div class="card" style="box-shadow:none">
              <div class="hd"><h2>Top authors (filtered)</h2></div>
              <div class="bd"><div id="chartTopAuthors" class="chart"></div></div>
            </div>
            <div class="card" style="box-shadow:none">
              <div class="hd"><h2>Publications by year (selected author)</h2></div>
              <div class="bd"><div id="chartAuthorYears" class="chart"></div></div>
            </div>
            <div class="card" style="box-shadow:none">
              <div class="hd"><h2>Team size distribution (filtered)</h2></div>
              <div class="bd"><div id="chartTeam" class="chart"></div></div>
            </div>
            <div class="card" style="box-shadow:none">
              <div class="hd"><h2>Coauthor network (selected author)</h2></div>
              <div class="bd"><svg id="coauthorSvg" width="100%" height="330"></svg></div>
            </div>
          </div>

          <div style="height:14px"></div>

          <div class="card" style="box-shadow:none">
            <div class="hd">
              <h2>Authors table</h2>
              <span class="muted" style="font-size:12px">Merged by dblp pid when available â€¢ Click a row to select</span>
            </div>
            <div class="bd">
              <div class="tablewrap">
                <table id="authorsTbl">
                  <thead>
                    <tr>
                      <th data-k="name">Author</th>
                      <th data-k="pubs">Pubs</th>
                      <th data-k="activeYears">Active yrs</th>
                      <th data-k="firstAuth">First</th>
                      <th data-k="lastAuth">Last</th>
                      <th data-k="solo">Solo</th>
                      <th data-k="coauthors">Coauthors</th>
                      <th data-k="avgTeam">Avg team</th>
                      <th data-k="firstYear">First yr</th>
                      <th data-k="lastYear">Last yr</th>
                      <th data-k="aliases">Aliases</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>

              <div style="height:12px"></div>
              <div class="small muted">
                Data source: local <span class="mono">./data/sigmetrics.json</span> (preferred), fallback dblp Search API (JSONP).
                Authors are unified by dblp person id (pid) when present.
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
/**
 * Offline-first SIGMETRICS Authors Dashboard
 * - Prefers local data/sigmetrics.json
 * - Falls back to dblp JSONP if local file missing
 * - Author identity merged by pid when available
 */

/* ---------- Theme helpers ---------- */
function getEffectiveTheme(){
  const manual = document.documentElement.getAttribute("data-theme");
  if(manual === "dark" || manual === "light") return manual;
  return (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) ? "dark" : "light";
}
function plotThemeLayout(){
  const dark = getEffectiveTheme() === "dark";
  return {
    font: { color: dark ? "rgba(232,238,246,.92)" : "rgba(16,24,40,.92)" },
    xaxis: {
      tickfont: { color: dark ? "rgba(232,238,246,.80)" : "rgba(16,24,40,.75)" },
      titlefont:{ color: dark ? "rgba(232,238,246,.85)" : "rgba(16,24,40,.85)" },
      gridcolor: dark ? "rgba(255,255,255,.12)" : "rgba(16,24,40,.10)",
      zerolinecolor: dark ? "rgba(255,255,255,.12)" : "rgba(16,24,40,.10)"
    },
    yaxis: {
      tickfont: { color: dark ? "rgba(232,238,246,.85)" : "rgba(16,24,40,.80)" },
      titlefont:{ color: dark ? "rgba(232,238,246,.85)" : "rgba(16,24,40,.85)" },
      gridcolor: dark ? "rgba(255,255,255,.06)" : "rgba(16,24,40,.08)"
    }
  };
}

const CACHE_KEY = "sigmetrics_authors_dashboard_v3_pid_merge";
const CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 14;
const MAX_HITS_PER_TOC = 1000;
const START_YEAR = 1974;

/* Theme state */
const THEME_KEY = "sigmetrics_theme";
function applyTheme(mode){
  const root = document.documentElement;
  if(mode === "system") root.removeAttribute("data-theme");
  else root.setAttribute("data-theme", mode);
}
function safeResizePlots(){
  const ids = ["chartTopAuthors","chartAuthorYears","chartTeam"];
  for(const id of ids){
    try{ Plotly.Plots.resize(id); }catch{}
  }
}
function initTheme(){
  const sel = document.getElementById("themeSelect");
  if(!sel) return;
  const saved = localStorage.getItem(THEME_KEY) || "system";
  sel.value = saved;
  applyTheme(saved);

  sel.addEventListener("change", () => {
    const v = sel.value;
    localStorage.setItem(THEME_KEY, v);
    applyTheme(v);
    try{ applyFilters(); } catch {}
    setTimeout(safeResizePlots, 50);
  });
}

/* ---------- Utility ---------- */
const el = (id) => document.getElementById(id);
const statusLog = el("statusLog");
const progBar = el("progBar");
const toast = el("toast");

function log(line){
  statusLog.textContent = (statusLog.textContent === "Idle." ? "" : statusLog.textContent + "\n") + line;
  statusLog.scrollTop = statusLog.scrollHeight;
}
function setProgress(p){ progBar.style.width = `${Math.max(0, Math.min(100, p))}%`; }
function showToast(msg){
  toast.textContent = msg;
  toast.classList.add("show");
  setTimeout(() => toast.classList.remove("show"), 3000);
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function uniq(arr){ return [...new Set(arr)]; }
function median(arr){
  if(arr.length === 0) return null;
  const a = [...arr].sort((x,y)=>x-y);
  const mid = Math.floor(a.length/2);
  return a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2;
}
function fmt(n){
  if(n == null) return "â€”";
  if(typeof n === "number" && Number.isFinite(n)){
    if(Math.abs(n) >= 1000) return n.toLocaleString();
    if(Math.abs(n) < 10 && n % 1 !== 0) return n.toFixed(2);
    return n.toLocaleString();
  }
  return String(n);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ---------- JSONP helper (fallback) ---------- */
function jsonp(url, {timeoutMs=20000} = {}) {
  return new Promise((resolve, reject) => {
    const cb = "__dblp_cb_" + Math.random().toString(36).slice(2);
    const u = new URL(url);
    u.searchParams.set("callback", cb);

    let done = false;
    const script = document.createElement("script");

    const timer = setTimeout(() => {
      if (done) return;
      done = true;
      cleanup();
      reject(new Error("JSONP timeout"));
    }, timeoutMs);

    function cleanup() {
      clearTimeout(timer);
      try { delete window[cb]; } catch {}
      script.remove();
    }

    window[cb] = (data) => {
      if (done) return;
      done = true;
      cleanup();
      resolve(data);
    };

    script.onerror = () => {
      if (done) return;
      done = true;
      cleanup();
      reject(new Error("JSONP script load failed (CSP?)"));
    };

    script.src = u.toString();
    document.head.appendChild(script);
  });
}

function buildDblpTocJsonpUrl(bhtKey){
  const q = `toc:${bhtKey}:`;
  const url = new URL("https://dblp.org/search/publ/api");
  url.searchParams.set("format","jsonp");
  url.searchParams.set("h", String(MAX_HITS_PER_TOC));
  url.searchParams.set("q", q);
  return url.toString();
}

function toAuthorObj(x){
  if(typeof x === "string"){
    const name = x.trim();
    return { id: "name:" + name, pid: null, name };
  }
  if(x && typeof x === "object"){
    const name = (x.text || "").trim() || String(x);
    const pid = (x["@pid"] || x.pid || "").trim() || null;
    return { id: pid ? ("pid:" + pid) : ("name:" + name), pid, name };
  }
  const name = String(x).trim();
  return { id: "name:" + name, pid: null, name };
}

function normalizeAuthors(authNode){
  if(!authNode) return [];
  const a = authNode.author;
  if(!a) return [];
  if(Array.isArray(a)) return a.map(toAuthorObj).filter(z => z && z.name);
  return [toAuthorObj(a)].filter(z => z && z.name);
}

/* ---------- State ---------- */
let dataset = null;
let filteredAuthors = [];
let selectedAuthorId = null;

/* ---------- Cache ---------- */
function loadCache(){
  try{
    const raw = localStorage.getItem(CACHE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj?.fetchedAt) return null;
    if(Date.now() - obj.fetchedAt > CACHE_TTL_MS) return null;
    return obj;
  }catch{
    return null;
  }
}
function saveCache(obj){
  try{ localStorage.setItem(CACHE_KEY, JSON.stringify(obj)); }
  catch(e){ console.warn("Cache save failed:", e); }
}
function clearCache(){ localStorage.removeItem(CACHE_KEY); }
function setCacheState(){
  const cached = loadCache();
  el("cacheState").textContent = cached ? "cache: ready" : "cache: empty";
}

/* ---------- Filters ---------- */
function getFilters(){
  const q = el("qAuthor").value.trim().toLowerCase();
  const sortMetric = el("sortMetric").value;
  const minPubs = +el("minPubs").value;
  const yMin = +el("yearMin").value;
  const yMax = +el("yearMax").value;
  return {q, sortMetric, minPubs, yMin: Math.min(yMin,yMax), yMax: Math.max(yMin,yMax)};
}

function authorProfileUrl(authorId){
  if(!authorId || !authorId.startsWith("pid:")) return null;
  const pid = authorId.slice(4);
  return `https://dblp.org/pid/${pid}.html`;
}

function applyFilters(){
  if(!dataset) return;

  const {q, sortMetric, minPubs, yMin, yMax} = getFilters();
  const recs = dataset.records.filter(r => r.year >= yMin && r.year <= yMax);

  // recompute per-author within range
  const tmp = new Map();
  const getA = (id) => {
    if(!tmp.has(id)) tmp.set(id, {
      id, pid: dataset.authorMeta[id]?.pid || null,
      pubs:0, firstAuth:0, lastAuth:0, solo:0,
      years:new Set(), coauthors:new Set(), teamSum:0
    });
    return tmp.get(id);
  };

  for(const r of recs){
    const team = r.authors.length || 0;
    for(let i=0;i<r.authors.length;i++){
      const a = r.authors[i];
      const s = getA(a.id);
      s.pubs += 1;
      s.years.add(r.year);
      s.teamSum += team;
      if(team === 1) s.solo += 1;
      if(i === 0) s.firstAuth += 1;
      if(i === r.authors.length-1) s.lastAuth += 1;

      for(let j=0;j<r.authors.length;j++){
        if(j===i) continue;
        s.coauthors.add(r.authors[j].id);
      }
    }
  }

  let rows = [...tmp.values()].map(s => {
    const meta = dataset.authorMeta[s.id] || {};
    const aliases = meta.aliases || [];
    const name = meta.canonicalName || meta.name || s.id;
    const yearsArr = [...s.years];
    return {
      id: s.id,
      pid: s.pid,
      name,
      aliases,
      pubs: s.pubs,
      firstAuth: s.firstAuth,
      lastAuth: s.lastAuth,
      solo: s.solo,
      coauthors: s.coauthors.size,
      avgTeam: s.pubs ? (s.teamSum / s.pubs) : 0,
      activeYears: s.years.size,
      firstYear: yearsArr.length ? Math.min(...yearsArr) : null,
      lastYear: yearsArr.length ? Math.max(...yearsArr) : null
    };
  });

  if(q){
    rows = rows.filter(r => {
      if(r.name.toLowerCase().includes(q)) return true;
      return (r.aliases || []).some(a => a.toLowerCase().includes(q));
    });
  }

  rows = rows.filter(r => r.pubs >= minPubs);

  rows.sort((a,b) => {
    const av = a[sortMetric], bv = b[sortMetric];
    if(typeof av === "string") return av.localeCompare(bv);
    if(bv === av) return a.name.localeCompare(b.name);
    return bv - av;
  });

  filteredAuthors = rows;
  el("matchCount").textContent = `${rows.length} shown`;

  renderTable(rows);
  renderTopAuthors(rows);
  renderTeamHistogram();
  refreshSelectedAuthor();
}

/* ---------- Table ---------- */
function renderTable(rows){
  const tbody = el("authorsTbl").querySelector("tbody");
  tbody.innerHTML = "";
  const frag = document.createDocumentFragment();

  for(const r of rows){
    const url = authorProfileUrl(r.id);

    const nameCell = url
      ? `<a class="link" href="${escapeHtml(url)}" target="_blank" rel="noreferrer">${escapeHtml(r.name)}</a>`
      : `<span class="link" data-authorid="${escapeHtml(r.id)}">${escapeHtml(r.name)}</span>`;

    const aliases = (r.aliases || []).filter(a => a && a !== r.name);
    const aliasesTxt = aliases.length ? escapeHtml(aliases.slice(0,4).join(" Â· ")) + (aliases.length > 4 ? " â€¦" : "") : "â€”";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${nameCell}</td>
      <td>${fmt(r.pubs)}</td>
      <td>${fmt(r.activeYears)}</td>
      <td>${fmt(r.firstAuth)}</td>
      <td>${fmt(r.lastAuth)}</td>
      <td>${fmt(r.solo)}</td>
      <td>${fmt(r.coauthors)}</td>
      <td>${fmt(r.avgTeam)}</td>
      <td>${fmt(r.firstYear)}</td>
      <td>${fmt(r.lastYear)}</td>
      <td class="muted">${aliasesTxt}</td>
    `;
    frag.appendChild(tr);
  }

  tbody.appendChild(frag);

  tbody.querySelectorAll("[data-authorid]").forEach(a => {
    a.addEventListener("click", () => {
      const id = a.getAttribute("data-authorid");
      if(id) selectAuthor(id);
    });
  });
}

/* ---------- Charts (Plotly themed) ---------- */
function renderTopAuthors(rows){
  const top = rows.slice(0, 25).reverse();
  const names = top.map(r => r.name);
  const vals  = top.map(r => r.pubs);
  const theme = plotThemeLayout();

  const height = Math.max(420, names.length * 30 + 110);
  const maxLen = names.reduce((m, s) => Math.max(m, (s || "").length), 0);
  const leftMargin = Math.max(180, Math.min(520, 90 + maxLen * 7));

  const colors = names.map((_, i) =>
    i % 2 === 0 ? "rgba(110,231,255,.80)" : "rgba(167,139,250,.75)"
  );

  const trace = {
    type: "bar",
    orientation: "h",
    y: names,
    x: vals,
    marker: { color: colors },
    hovertemplate: "%{y}<br>Pubs: %{x}<extra></extra>"
  };

  const layout = {
    height,
    margin: { l: leftMargin, r: 12, t: 10, b: 70 },
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: theme.font,
    xaxis: {
      title: "Publications",
      automargin: true,
      ...theme.xaxis
    },
    yaxis: {
      type: "category",
      tickmode: "array",
      tickvals: names,
      ticktext: names,
      automargin: true,
      ticklabeloverflow: "allow",
      tickfont: { ...(theme.yaxis.tickfont || {}), size: 13 },
      gridcolor: theme.yaxis.gridcolor
    }
  };

  Plotly.newPlot("chartTopAuthors", [trace], layout, {displayModeBar:false, responsive:true})
    .then(() => Plotly.Plots.resize("chartTopAuthors"));
}

function renderTeamHistogram(){
  if(!dataset) return;
  const {yMin, yMax} = getFilters();
  const recs = dataset.records.filter(r => r.year >= yMin && r.year <= yMax);
  const teams = recs.map(r => r.authors.length).filter(x=>x>0);
  const theme = plotThemeLayout();

  const trace = {
    type: "histogram",
    x: teams,
    xbins: {start: 1, end: Math.max(2, ...teams, 10), size: 1},
    hovertemplate: "Team size %{x}<br>Count %{y}<extra></extra>"
  };

  const layout = {
    margin: {l: 45, r: 10, t: 10, b: 40},
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: theme.font,
    xaxis: { title: "Authors per paper", dtick: 1, ...theme.xaxis },
    yaxis: { title: "Papers", ...theme.yaxis },
    height: 330
  };

  Plotly.newPlot("chartTeam", [trace], layout, {displayModeBar:false, responsive:true});
}

function renderAuthorYears(authorId){
  const {yMin, yMax} = getFilters();
  const recs = dataset.records.filter(r => r.year >= yMin && r.year <= yMax && r.authorIds.includes(authorId));
  const counts = new Map();
  for(const r of recs) counts.set(r.year, (counts.get(r.year)||0)+1);
  const years = [...counts.keys()].sort((a,b)=>a-b);
  const vals = years.map(y => counts.get(y));
  const theme = plotThemeLayout();

  const trace = {
    type: "scatter",
    mode: "lines+markers",
    x: years,
    y: vals,
    hovertemplate: "Year %{x}<br>Pubs %{y}<extra></extra>"
  };

  const layout = {
    margin: {l: 45, r: 10, t: 10, b: 40},
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: theme.font,
    xaxis: { title: "Year", ...theme.xaxis },
    yaxis: { title: "Publications", ...theme.yaxis },
    height: 330
  };

  Plotly.newPlot("chartAuthorYears", [trace], layout, {displayModeBar:false, responsive:true});
}

/* ---------- Coauthor network (less crowded + hover highlight + short labels) ---------- */
function shortName(full){
  const s = (full || "").trim();
  if(!s) return "";
  const parts = s.split(/\s+/);
  if(parts.length === 1) return parts[0].slice(0, 14);
  const last = parts[parts.length-1];
  const first = parts[0][0] || "";
  return `${first}. ${last}`.slice(0, 14);
}

function renderCoauthorNetwork(authorId){
  const svg = d3.select("#coauthorSvg");
  svg.selectAll("*").remove();

  if(!dataset || !authorId){
    const w = svg.node().getBoundingClientRect().width || 600;
    svg.attr("viewBox", `0 0 ${w} 330`);
    svg.append("text")
      .attr("x", 14).attr("y", 40)
      .attr("fill", "currentColor")
      .attr("opacity", 0.6)
      .style("font-size", "12px")
      .text("Select an author to see their coauthor network.");
    return;
  }

  const {yMin, yMax} = getFilters();
  const recs = dataset.records.filter(r => r.year >= yMin && r.year <= yMax && r.authorIds.includes(authorId));

  const co = new Map();
  for(const r of recs){
    for(const aId of r.authorIds){
      if(aId === authorId) continue;
      co.set(aId, (co.get(aId)||0) + 1);
    }
  }

  const MAX_NODES = 16; // 12â€“18 works best
  const top = [...co.entries()].sort((a,b)=>b[1]-a[1]).slice(0, MAX_NODES);

  const nodes = [{id: authorId, w: 0}, ...top.map(([id,w]) => ({id, w}))];
  const links = top.map(([id,w]) => ({source: authorId, target: id, w}));

  const box = svg.node().getBoundingClientRect();
  const width = Math.max(520, box.width || 700);
  const height = 330;
  svg.attr("viewBox", `0 0 ${width} ${height}`);

  const sim = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d=>d.id)
      .distance(d => 85 + (MAX_NODES - Math.min(MAX_NODES, d.w))*3)
      .strength(0.9)
    )
    .force("charge", d3.forceManyBody().strength(-260))
    .force("center", d3.forceCenter(width/2, height/2))
    .force("collide", d3.forceCollide().radius(d => d.id===authorId ? 34 : 18));

  const link = svg.append("g")
    .attr("stroke", "currentColor")
    .attr("opacity", 0.20)
    .selectAll("line")
    .data(links)
    .join("line")
    .attr("stroke-width", d => 1 + Math.min(6, d.w));

  const node = svg.append("g")
    .selectAll("g")
    .data(nodes)
    .join("g")
    .call(d3.drag()
      .on("start", (event, d) => {
        if(!event.active) sim.alphaTarget(0.3).restart();
        d.fx = d.x; d.fy = d.y;
      })
      .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
      .on("end", (event, d) => {
        if(!event.active) sim.alphaTarget(0);
        d.fx = null; d.fy = null;
      })
    );

  node.append("circle")
    .attr("r", d => d.id===authorId ? 22 : 10 + Math.min(8, d.w))
    .attr("fill", d => d.id===authorId ? "rgba(110,231,255,.95)" : "rgba(167,139,250,.75)")
    .attr("stroke", "rgba(255,255,255,.25)")
    .attr("stroke-width", 1);

  node.append("title")
    .text(d => {
      const meta = dataset.authorMeta[d.id] || {};
      const nm = meta.canonicalName || meta.name || d.id;
      return d.id===authorId ? nm : `${nm}\nCoauthored papers: ${d.w}`;
    });

  node.append("text")
    .attr("x", d => d.id===authorId ? 26 : 14)
    .attr("y", 4)
    .attr("fill", "currentColor")
    .attr("opacity", 0.78)
    .style("font-size", d => d.id===authorId ? "12px" : "11px")
    .text(d => {
      const meta = dataset.authorMeta[d.id] || {};
      const nm = meta.canonicalName || meta.name || d.id;
      return d.id===authorId ? nm : shortName(nm);
    });

  function setFocus(focusId){
    node.attr("opacity", d => !focusId ? 1 : (d.id===focusId || d.id===authorId ? 1 : 0.18));
    link.attr("opacity", d => {
      if(!focusId) return 0.20;
      const sid = (d.source && d.source.id) ? d.source.id : d.source;
      const tid = (d.target && d.target.id) ? d.target.id : d.target;
      return (sid===focusId || tid===focusId) ? 0.55 : 0.06;
    });
  }

  node.on("mouseenter", (event, d) => setFocus(d.id));
  node.on("mouseleave", () => setFocus(null));

  sim.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);
    node.attr("transform", d => `translate(${d.x},${d.y})`);
  });

  node.on("click", (event, d) => selectAuthor(d.id));
}

/* ---------- Selection ---------- */
function selectAuthor(authorId){
  selectedAuthorId = authorId;
  refreshSelectedAuthor();
}

function refreshSelectedAuthor(){
  if(!dataset){
    el("selAuthor").textContent = "Select an author";
    el("selMeta").textContent = "Click a row in the table to inspect an author.";
    el("selBadge").style.display = "none";
    Plotly.purge("chartAuthorYears");
    renderCoauthorNetwork(null);
    return;
  }
  if(!selectedAuthorId){
    renderCoauthorNetwork(null);
    return;
  }

  const meta = dataset.authorMeta[selectedAuthorId] || {};
  const name = meta.canonicalName || meta.name || selectedAuthorId;
  const {yMin, yMax} = getFilters();
  const recs = dataset.records.filter(r => r.year >= yMin && r.year <= yMax && r.authorIds.includes(selectedAuthorId));

  const pubs = recs.length;
  const years = uniq(recs.map(r=>r.year)).sort((a,b)=>a-b);
  const firstYear = years[0] ?? null;
  const lastYear = years[years.length-1] ?? null;
  const teams = recs.map(r => r.authors.length);
  const avgTeam = teams.length ? teams.reduce((a,b)=>a+b,0)/teams.length : 0;

  let firstAuth=0, lastAuth=0, solo=0;
  const co = new Map();
  for(const r of recs){
    if(r.authorIds.length===1) solo++;
    if(r.authorIds[0]===selectedAuthorId) firstAuth++;
    if(r.authorIds[r.authorIds.length-1]===selectedAuthorId) lastAuth++;
    for(const aId of r.authorIds){
      if(aId===selectedAuthorId) continue;
      co.set(aId, (co.get(aId)||0)+1);
    }
  }

  const topCo = [...co.entries()].sort((a,b)=>b[1]-a[1]).slice(0, 5).map(([id,w]) => {
    const m = dataset.authorMeta[id] || {};
    const n = m.canonicalName || m.name || id;
    return `${n} (${w})`;
  }).join(" Â· ");

  el("selAuthor").textContent = name;
  el("selBadge").style.display = "inline-flex";
  el("selBadgeText").textContent = `${pubs} pubs`;

  const prof = authorProfileUrl(selectedAuthorId);
  const profHtml = prof ? ` Â· <a class="link" href="${escapeHtml(prof)}" target="_blank" rel="noreferrer">dblp profile</a>` : "";

  el("selMeta").innerHTML = `
    <span><b>${fmt(firstYear)}</b> â†’ <b>${fmt(lastYear)}</b></span>
    <span class="muted">Â·</span>
    <span>first: <b>${fmt(firstAuth)}</b>, last: <b>${fmt(lastAuth)}</b>, solo: <b>${fmt(solo)}</b></span>
    <span class="muted">Â·</span>
    <span>avg team: <b>${fmt(avgTeam)}</b></span>
    <span class="muted">Â·</span>
    <span>top coauthors: <span class="muted">${escapeHtml(topCo || "â€”")}</span></span>
    ${profHtml}
  `;

  renderAuthorYears(selectedAuthorId);
  renderCoauthorNetwork(selectedAuthorId);
}

/* ---------- Summary ---------- */
function renderSummary(){
  if(!dataset) return;

  const years = uniq(dataset.records.map(r=>r.year)).sort((a,b)=>a-b);
  el("recCount").textContent = fmt(dataset.records.length);
  el("authCount").textContent = fmt(Object.keys(dataset.authorMeta).length);
  el("yearSpan").textContent = years.length ? `${years[0]}â€“${years[years.length-1]}` : "â€”";

  const stamp = new Date(dataset.fetchedAt).toLocaleString();
  el("datasetStamp").textContent = `dataset: fetched ${stamp}`;

  const topAuthor = [...dataset.authors].sort((a,b)=>b.pubs-a.pubs)[0];
  el("kTopAuthor").textContent = topAuthor ? topAuthor.name : "â€”";
  el("kTopAuthorHint").textContent = topAuthor ? `${fmt(topAuthor.pubs)} publications` : "â€”";

  const teams = dataset.records.map(r=>r.authors.length).filter(x=>x>0);
  const medTeam = median(teams);
  el("kMedTeam").textContent = medTeam ? fmt(medTeam) : "â€”";
  el("kMedTeamHint").textContent = teams.length ? `${fmt(teams.length)} papers` : "â€”";

  const pubsPerAuthor = dataset.authors.map(a=>a.pubs).sort((a,b)=>a-b);
  const medPubs = median(pubsPerAuthor);
  el("kMedPubs").textContent = medPubs ? fmt(medPubs) : "â€”";
  el("kMedPubsHint").textContent = `${fmt(dataset.authors.length)} authors`;

  const yearCounts = new Map();
  for(const r of dataset.records) yearCounts.set(r.year, (yearCounts.get(r.year)||0)+1);
  const topYear = [...yearCounts.entries()].sort((a,b)=>b[1]-a[1])[0];
  el("kTopYear").textContent = topYear ? String(topYear[0]) : "â€”";
  el("kTopYearHint").textContent = topYear ? `${fmt(topYear[1])} records` : "â€”";
}

/* ---------- Sliders & sorting ---------- */
function setupYearSliders(){
  const years = dataset ? uniq(dataset.records.map(r=>r.year)).sort((a,b)=>a-b) : [START_YEAR, new Date().getFullYear()];
  const minY = years[0] ?? START_YEAR;
  const maxY = years[years.length-1] ?? new Date().getFullYear();

  const yMin = el("yearMin");
  const yMax = el("yearMax");
  yMin.min = minY; yMin.max = maxY;
  yMax.min = minY; yMax.max = maxY;

  // Respect the HTML defaults (2015â€“2026), but clamp into available range
  yMin.value = clamp(+yMin.value || minY, minY, maxY);
  yMax.value = clamp(+yMax.value || maxY, minY, maxY);

  const updateLabel = () => {
    const a = Math.min(+yMin.value, +yMax.value);
    const b = Math.max(+yMin.value, +yMax.value);
    el("yearRangeLabel").textContent = `${a}â€“${b}`;
  };
  updateLabel();

  yMin.addEventListener("input", () => { updateLabel(); applyFilters(); });
  yMax.addEventListener("input", () => { updateLabel(); applyFilters(); });
}

function setupTableHeaderSorting(){
  const ths = el("authorsTbl").querySelectorAll("th[data-k]");
  ths.forEach(th => {
    th.addEventListener("click", () => {
      const k = th.getAttribute("data-k");
      if(["pubs","firstAuth","lastAuth","activeYears","coauthors","solo","avgTeam"].includes(k)){
        el("sortMetric").value = k;
        applyFilters();
      }
    });
  });
}

/* ---------- Dataset builders ---------- */
function chooseCanonicalName(aliasCounts){
  const entries = [...aliasCounts.entries()];
  entries.sort((a,b) => (b[1]-a[1]) || (a[0].length-b[0].length));
  return entries[0]?.[0] || null;
}

async function loadLocalDataset(){
  const res = await fetch("./data/sigmetrics.json", { cache: "no-store" });
  if(!res.ok) throw new Error("Local dataset not found: data/sigmetrics.json");
  return res.json();
}

async function buildDatasetFromDblpJsonp(){
  statusLog.textContent = "";
  setProgress(1);
  log("Fetching dblp via JSONPâ€¦ (pid-based author merging)");

  const endYear = new Date().getFullYear();
  const allRecords = [];

  const authorMetaAgg = new Map();
  function observeAuthor(a){
    if(!authorMetaAgg.has(a.id)){
      authorMetaAgg.set(a.id, { id:a.id, pid:a.pid, aliasCounts:new Map() });
    }
    const m = authorMetaAgg.get(a.id);
    m.pid = m.pid || a.pid || null;
    const nm = (a.name || "").trim();
    if(nm) m.aliasCounts.set(nm, (m.aliasCounts.get(nm)||0) + 1);
  }

  for(let year = START_YEAR; year <= endYear; year++){
    const apiUrl = buildDblpTocJsonpUrl(`db/conf/sigmetrics/sigmetrics${year}.bht`);
    const pct = 5 + 78 * ((year - START_YEAR) / (endYear - START_YEAR));
    setProgress(pct);

    log(`${year}: queryingâ€¦`);
    let data;
    try{
      data = await jsonp(apiUrl, {timeoutMs: 20000});
    }catch(e){
      log(`  âš ï¸ ${year}: ${e.message}`);
      continue;
    }

    const hits = data?.result?.hits?.hit;
    const hitArr = hits ? (Array.isArray(hits) ? hits : [hits]) : [];
    if(hitArr.length === 0){
      log(`  â†’ 0 records (skip)`);
      continue;
    }
    log(`  â†’ ${hitArr.length} records`);

    for(const h of hitArr){
      const info = h?.info || {};
      const title = (info.title || "").trim();
      if(!title) continue;

      const authors = normalizeAuthors(info.authors);
      authors.forEach(observeAuthor);

      const y = +(info.year || year);
      const authorIds = authors.map(a => a.id);

      allRecords.push({
        year: y,
        title,
        authors,
        authorIds,
        venue: info.venue || "",
        pages: info.pages || "",
        doi: info.doi || "",
        url: info.url || "",
        key: info.key || "",
        type: info.type || ""
      });
    }
  }

  setProgress(86);
  log("Finalizing canonical names + aliasesâ€¦");

  const authorMeta = {};
  for(const [id, m] of authorMetaAgg.entries()){
    const canonical = chooseCanonicalName(m.aliasCounts) || id;
    const aliases = [...m.aliasCounts.keys()].sort((a,b)=>a.localeCompare(b));
    authorMeta[id] = { id, pid: m.pid || null, name: canonical, canonicalName: canonical, aliases };
  }

  setProgress(90);
  log("Aggregating author metricsâ€¦");

  const authorsMap = new Map();
  function getAuthorStats(authorId){
    if(!authorsMap.has(authorId)){
      authorsMap.set(authorId, { id: authorId, pubs:0, firstAuth:0, lastAuth:0, solo:0, years:new Map(), coauthors:new Map(), teamSizes:[] });
    }
    return authorsMap.get(authorId);
  }

  for(const r of allRecords){
    for(let i=0;i<r.authorIds.length;i++){
      const aId = r.authorIds[i];
      const s = getAuthorStats(aId);
      s.pubs += 1;
      s.years.set(r.year, (s.years.get(r.year)||0) + 1);
      s.teamSizes.push(r.authorIds.length);

      if(r.authorIds.length === 1) s.solo += 1;
      if(i === 0) s.firstAuth += 1;
      if(i === r.authorIds.length - 1) s.lastAuth += 1;

      for(let j=0;j<r.authorIds.length;j++){
        if(j === i) continue;
        const bId = r.authorIds[j];
        s.coauthors.set(bId, (s.coauthors.get(bId)||0) + 1);
      }
    }
  }

  const authors = [];
  for(const s of authorsMap.values()){
    const yearsActive = [...s.years.keys()].sort((a,b)=>a-b);
    const firstYear = yearsActive[0] ?? null;
    const lastYear  = yearsActive[yearsActive.length-1] ?? null;

    const meta = authorMeta[s.id] || {};
    const avgTeam = s.teamSizes.length ? (s.teamSizes.reduce((a,b)=>a+b,0) / s.teamSizes.length) : 0;

    authors.push({
      id: s.id,
      pid: meta.pid || null,
      name: meta.canonicalName || meta.name || s.id,
      aliases: meta.aliases || [],
      pubs: s.pubs,
      firstAuth: s.firstAuth,
      lastAuth: s.lastAuth,
      solo: s.solo,
      coauthors: s.coauthors.size,
      avgTeam,
      activeYears: yearsActive.length,
      firstYear,
      lastYear
    });
  }

  setProgress(96);
  log("Done.");

  return { fetchedAt: Date.now(), records: allRecords, authorMeta, authors };
}

/* ---------- Init ---------- */
async function init({forceRefresh=false}={}){
  setCacheState();

  // Prefer local dataset if present
  try{
    dataset = await loadLocalDataset();
    renderSummary();
    setupYearSliders();
    applyFilters();
    refreshSelectedAuthor();
    el("cacheState").textContent = "dataset: local";
    showToast("Loaded local dataset.");
    return;
  }catch(e){
    log("Local dataset missing; falling back to cache/DBLP.");
  }

  if(!forceRefresh){
    const cached = loadCache();
    if(cached){
      dataset = cached;
      renderSummary();
      setupYearSliders();
      applyFilters();
      refreshSelectedAuthor();
      el("cacheState").textContent = "cache: loaded";
      showToast("Loaded cached dataset.");
      return;
    }
  }

  el("cacheState").textContent = "cache: fetching";
  setProgress(0);
  statusLog.textContent = "";

  try{
    dataset = await buildDatasetFromDblpJsonp();
    saveCache(dataset);
    setCacheState();
    renderSummary();
    setupYearSliders();
    applyFilters();
    refreshSelectedAuthor();
    setProgress(100);
    showToast("Loaded fresh dataset from dblp.");
  }catch(e){
    console.error(e);
    log("ERROR: " + (e?.message || e));
    el("cacheState").textContent = "cache: error";
    setProgress(0);
    showToast("Load failed (see status log).");
  }
}

/* ---------- UI wiring ---------- */
el("btnLoad").addEventListener("click", () => init({forceRefresh:true}));
el("btnClearCache").addEventListener("click", () => {
  clearCache();
  dataset = null;
  setCacheState();
  statusLog.textContent = "Cache cleared. Click â€œLoad / Refresh from dblpâ€.";
  el("recCount").textContent = "â€”";
  el("authCount").textContent = "â€”";
  el("yearSpan").textContent = "â€”";
  el("datasetStamp").textContent = "dataset: â€”";
  selectedAuthorId = null;

  Plotly.purge("chartTopAuthors");
  Plotly.purge("chartAuthorYears");
  Plotly.purge("chartTeam");
  renderCoauthorNetwork(null);
  el("authorsTbl").querySelector("tbody").innerHTML = "";
  showToast("Cache cleared.");
});

el("qAuthor").addEventListener("input", () => applyFilters());
el("sortMetric").addEventListener("change", () => applyFilters());
el("minPubs").addEventListener("change", () => applyFilters());

setupTableHeaderSorting();
renderCoauthorNetwork(null);

/* Init theme before auto-init */
initTheme();
if (window.matchMedia) {
  const mq = window.matchMedia("(prefers-color-scheme: dark)");
  mq.addEventListener?.("change", () => {
    if (!document.documentElement.getAttribute("data-theme")) {
      applyFilters();
      setTimeout(safeResizePlots, 50);
    }
  });
}

/* Auto-init */
init();
</script>
</body>
</html>
